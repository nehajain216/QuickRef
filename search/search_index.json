{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My favorite development tools CommandLine Tools Babun - a Windows shell you will love!. iTerms2 - iTerm2 is a replacement for Terminal that works on Macs with macOS 10.8 or newer. Oh-My-Zsh - Your terminal never felt this good before. SdkMan - The Software Development Kit Manager. Editors Visual Studio Code Atom Sublime Text Task Tracking Tools Asana EverNote Trello Utilities Postman - REST Client Insomina - REST client Bitwarden - Password Manager SimpleMind - Mind Mapping tool GIF Brewery - Create GIFs Rambox - Messaging and emailing app that combines common web applications into one. Static Site Generators Hugo Jekyll MkDocs","title":"Home"},{"location":"#my-favorite-development-tools","text":"","title":"My favorite development tools"},{"location":"#commandline-tools","text":"Babun - a Windows shell you will love!. iTerms2 - iTerm2 is a replacement for Terminal that works on Macs with macOS 10.8 or newer. Oh-My-Zsh - Your terminal never felt this good before. SdkMan - The Software Development Kit Manager.","title":"CommandLine Tools"},{"location":"#editors","text":"Visual Studio Code Atom Sublime Text","title":"Editors"},{"location":"#task-tracking-tools","text":"Asana EverNote Trello","title":"Task Tracking Tools"},{"location":"#utilities","text":"Postman - REST Client Insomina - REST client Bitwarden - Password Manager SimpleMind - Mind Mapping tool GIF Brewery - Create GIFs Rambox - Messaging and emailing app that combines common web applications into one.","title":"Utilities"},{"location":"#static-site-generators","text":"Hugo Jekyll MkDocs","title":"Static Site Generators"},{"location":"general/links/","text":"Good article links Markdown https://guides.github.com/features/mastering-markdown/ Git https://www.keycdn.com/blog/git-cheat-sheet","title":"Links"},{"location":"general/links/#good-article-links","text":"","title":"Good article links"},{"location":"general/links/#markdown","text":"https://guides.github.com/features/mastering-markdown/","title":"Markdown"},{"location":"general/links/#git","text":"https://www.keycdn.com/blog/git-cheat-sheet","title":"Git"},{"location":"general/tips/","text":"MacOS Shortcuts Access hidden folders: shift + command + .","title":"Tips"},{"location":"general/tips/#macos-shortcuts","text":"Access hidden folders: shift + command + .","title":"MacOS Shortcuts"},{"location":"git/git-reference/","text":"To clone Git project from scratch: Create a repository in github * Goto working directory where project need to be cloned. Open command prompt and navigate to the working directory path cd working directory path Copy git repository path and type the below in command promt git clone git repository path Goto working directory , a new folder with repository name will get created and all the files in repository get copied to that folder Goto the project folder(unzip it) created from start.spring.io and copy all the files within the folder including hidden file Paste the files in working directory project folder Open the project using IDE (intelliJ, Eclipse)","title":"Git Reference"},{"location":"git/git-reference/#to-clone-git-project-from-scratch","text":"Create a repository in github * Goto working directory where project need to be cloned. Open command prompt and navigate to the working directory path cd working directory path Copy git repository path and type the below in command promt git clone git repository path Goto working directory , a new folder with repository name will get created and all the files in repository get copied to that folder Goto the project folder(unzip it) created from start.spring.io and copy all the files within the folder including hidden file Paste the files in working directory project folder Open the project using IDE (intelliJ, Eclipse)","title":"To clone Git project from scratch:"},{"location":"java/basics/","text":"Enum Enum is used for setting pre defined constants (like- days of week, moths, planets of solar system and so on) Enum cannot extends another class because it implicitly extends java.lang.Enum (and java doesnot support multiple inheritance) we can have variables, constructor and methods inside enum Variables inside Enum are implicitly final static","title":"Basics"},{"location":"java/basics/#enum","text":"Enum is used for setting pre defined constants (like- days of week, moths, planets of solar system and so on) Enum cannot extends another class because it implicitly extends java.lang.Enum (and java doesnot support multiple inheritance) we can have variables, constructor and methods inside enum Variables inside Enum are implicitly final static","title":"Enum"},{"location":"java/hibernate/","text":"JPA/Hibernate Quick Reference Introduction Hibernate is a persistence framework which is used to persist data from Java environment to database. JPA is a Object Relational Mapping framework. JPA is a Specification and Hibernate is implementation of JPA. There are other implementations of JPA like EclipseLink. Getting Started Maven Dependencies dependency groupId org.hibernate /groupId artifactId hibernate-entitymanager /artifactId version 4.3.6.Final /version /dependency Add database driver dependency groupId mysql /groupId artifactId mysql-connector-java /artifactId version 5.1.39 /version /dependency Create JPA Entity import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.Table ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; @Entity @Table ( name = persons ) public class Person { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = id ) private int id ; private String name ; ... ... // setters and getters } Configure database connection properties and JPA entities in src/main/resources/META-INF/persistence.xml persistence xmlns= http://xmlns.jcp.org/xml/ns/persistence xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd version= 2.1 persistence-unit name= jpa-demo transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider class com.nj.jpademo.entities.Person /class class com.nj.jpademo.entities.Address /class properties property name= javax.persistence.jdbc.url value= jdbc:mysql://localhost:3306/jpadb?useSSL=true / property name= javax.persistence.jdbc.user value= root / property name= javax.persistence.jdbc.password value= admin / property name= javax.persistence.jdbc.driver value= com.mysql.jdbc.Driver / property name= hibernate.show_sql value= true / property name= hibernate.format_sql value= true / property name= hibernate.dialect value= org.hibernate.dialect.MySQL5InnoDBDialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit /persistence Create EntityManagerFactory Notes: A connection to a database is represented by an EntityManager instance, which also provides functionality for performing operations on a database. An EntityManagerFactory is constructed for a specific database and the main role of an EntityManagerFactory instance is to support instantiation of EntityManager instances. import javax.persistence.EntityManager ; import javax.persistence.EntityManagerFactory ; import javax.persistence.Persistence ; public class PersistenceManager { private static final EntityManagerFactory emFactory ; private PersistenceManager () { } static { emFactory = Persistence . createEntityManagerFactory ( jpa-demo ); } public static EntityManager getEntityManager () { return emFactory . createEntityManager (); } public static void close () { emFactory . close (); } } Create EntityManager to perform database operations public class EmployeeDAO { public void save ( Person p ) { EntityManager em = PersistenceManager . getEntityManager (); em . getTransaction (). begin (); em . persist ( p ); em . getTransaction (). commit (); em . close (); } } Relationship Mappings //TODO One-To-Many //TODO Many-To-One //TODO One-To-One //TODO Many-To-Many","title":"Hibernate"},{"location":"java/hibernate/#jpahibernate-quick-reference","text":"","title":"JPA/Hibernate Quick Reference"},{"location":"java/hibernate/#introduction","text":"Hibernate is a persistence framework which is used to persist data from Java environment to database. JPA is a Object Relational Mapping framework. JPA is a Specification and Hibernate is implementation of JPA. There are other implementations of JPA like EclipseLink.","title":"Introduction"},{"location":"java/hibernate/#getting-started","text":"Maven Dependencies dependency groupId org.hibernate /groupId artifactId hibernate-entitymanager /artifactId version 4.3.6.Final /version /dependency Add database driver dependency groupId mysql /groupId artifactId mysql-connector-java /artifactId version 5.1.39 /version /dependency Create JPA Entity import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.Table ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; @Entity @Table ( name = persons ) public class Person { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = id ) private int id ; private String name ; ... ... // setters and getters } Configure database connection properties and JPA entities in src/main/resources/META-INF/persistence.xml persistence xmlns= http://xmlns.jcp.org/xml/ns/persistence xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd version= 2.1 persistence-unit name= jpa-demo transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider class com.nj.jpademo.entities.Person /class class com.nj.jpademo.entities.Address /class properties property name= javax.persistence.jdbc.url value= jdbc:mysql://localhost:3306/jpadb?useSSL=true / property name= javax.persistence.jdbc.user value= root / property name= javax.persistence.jdbc.password value= admin / property name= javax.persistence.jdbc.driver value= com.mysql.jdbc.Driver / property name= hibernate.show_sql value= true / property name= hibernate.format_sql value= true / property name= hibernate.dialect value= org.hibernate.dialect.MySQL5InnoDBDialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit /persistence Create EntityManagerFactory Notes: A connection to a database is represented by an EntityManager instance, which also provides functionality for performing operations on a database. An EntityManagerFactory is constructed for a specific database and the main role of an EntityManagerFactory instance is to support instantiation of EntityManager instances. import javax.persistence.EntityManager ; import javax.persistence.EntityManagerFactory ; import javax.persistence.Persistence ; public class PersistenceManager { private static final EntityManagerFactory emFactory ; private PersistenceManager () { } static { emFactory = Persistence . createEntityManagerFactory ( jpa-demo ); } public static EntityManager getEntityManager () { return emFactory . createEntityManager (); } public static void close () { emFactory . close (); } } Create EntityManager to perform database operations public class EmployeeDAO { public void save ( Person p ) { EntityManager em = PersistenceManager . getEntityManager (); em . getTransaction (). begin (); em . persist ( p ); em . getTransaction (). commit (); em . close (); } }","title":"Getting Started"},{"location":"java/hibernate/#relationship-mappings","text":"//TODO One-To-Many //TODO Many-To-One //TODO One-To-One //TODO Many-To-Many","title":"Relationship Mappings"},{"location":"java/servlets/","text":"Introduction In earlier days, suppose we have a web server (say Apache with port number 80) and there is a container named \"www\" and all the pre built HTMl files, images and so on are placed in that container (www) Now, when a request from browser is made to access the HTML page (say localhost:80/myapp1/index.html), then index.html present in myapp1 which is placed in www container will be rendered to the browser, however the content that is rendered is STATIC data and this model could not handle dynamic data (taking input from the user and displaying data accordingly). So, when need arose for dynamic content, JAVA proposed SERVLET as solution. Now we can says that it Webserver + servlet support. Now, when a request from browser is made to render the HTML page (say localhost:80/myapp1/index.html), then index.html present in myapp1 which is placed in webapp container will be rendered to the browser, but with the help of servlets. for end user it doesn't make any difference, however at the backend to handle dynamic content display, \"Deployment Descriptor (web.xml)\" comes into picture and based on the url, it decides which servlet class will handle the request and calls that respective which process the request and gives the output accordingly. Note: Deployment Descriptor are nothing but web.xml where we define URL Pattern, servlet class name and other details. Note: One important thing to remember is that there is only ONE instance of every servlet gets created. Now when multiple users access the same class what happens ? There is a concept of Thread pool. say by default, 10 threads are available to handle the request, and say three different request comes then every request is assigned a thread to handle it. All the three different thread will call the same class INSTANCE. Now any variable that is defined at class level can be accessed/manipulated by all the 3 different threads, so, for that reason, if its specific to the user, then it should be declared at method level (doGet, doPOST, and so on) and not at the class level. Because a different stacks gets created for every method based on thread.","title":"Servlets"},{"location":"java/servlets/#introduction","text":"In earlier days, suppose we have a web server (say Apache with port number 80) and there is a container named \"www\" and all the pre built HTMl files, images and so on are placed in that container (www) Now, when a request from browser is made to access the HTML page (say localhost:80/myapp1/index.html), then index.html present in myapp1 which is placed in www container will be rendered to the browser, however the content that is rendered is STATIC data and this model could not handle dynamic data (taking input from the user and displaying data accordingly). So, when need arose for dynamic content, JAVA proposed SERVLET as solution. Now we can says that it Webserver + servlet support. Now, when a request from browser is made to render the HTML page (say localhost:80/myapp1/index.html), then index.html present in myapp1 which is placed in webapp container will be rendered to the browser, but with the help of servlets. for end user it doesn't make any difference, however at the backend to handle dynamic content display, \"Deployment Descriptor (web.xml)\" comes into picture and based on the url, it decides which servlet class will handle the request and calls that respective which process the request and gives the output accordingly. Note: Deployment Descriptor are nothing but web.xml where we define URL Pattern, servlet class name and other details. Note: One important thing to remember is that there is only ONE instance of every servlet gets created. Now when multiple users access the same class what happens ? There is a concept of Thread pool. say by default, 10 threads are available to handle the request, and say three different request comes then every request is assigned a thread to handle it. All the three different thread will call the same class INSTANCE. Now any variable that is defined at class level can be accessed/manipulated by all the 3 different threads, so, for that reason, if its specific to the user, then it should be declared at method level (doGet, doPOST, and so on) and not at the class level. Because a different stacks gets created for every method based on thread.","title":"Introduction"},{"location":"java/spring-mvc/","text":"Spring MVC configuration Quick Reference Introduction Spring MVC is one of the most important modules of the Spring framework Important Notes: In Spring Web applications, there are two types of containers - Application context and Web Application Context. Application context is initiaized by ContextLoaderListener defined in web.xml This is a root container and generally contains components such as Services and DAO There will be one application context per application. Web Application context: This is a child context of Application context. Web Application context is initialized by Dispatcher servlet handlers/controllers/view-resolvers are managed by this context *View Resolver ViewResolver implementations are used to resolve the view pages by name we are providing the view pages directory and suffix location If a controller handler method returns \u201chome\u201d, view resolver will use view page located at /WEB-INF/views/home.jsp. Spring MVC configuration using XML Getting Started Maven Dependencies dependencies dependency groupId javax.servlet /groupId artifactId javax.servlet-api /artifactId scope provided /scope /dependency dependency groupId org.springframework /groupId artifactId spring-webmvc /artifactId /dependency dependency groupId org.slf4j /groupId artifactId jcl-over-slf4j /artifactId /dependency dependency groupId ch.qos.logback /groupId artifactId logback-classic /artifactId /dependency dependency groupId org.hibernate /groupId artifactId hibernate-validator /artifactId /dependency /dependencies Update web.xml file to include DispatcherServlet (one servlet) to receive all kinds of information. Here we have configured it as only one context that is WebApplication Context (but not as - Application context and WebApplication context - we have covered that scenario in javaconfig example ) servlet servlet-name dispatcher /servlet-name servlet-class org.springframework.web.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern / /url-pattern /servlet-mapping dispatcher-servlet.xml -- based on the servlet name (here \"dispatcher\", it will look for -servlet.xml file. If needed we can specify different name as well. However, here, we are creating dispatcher-servlet.xml only. / - This means for all the URL patterns, request will be handled by dispatcher. context:annotation-config /context:annotation-config context:component-scan base-package= com.nj.blog /context:component-scan mvc:annotation-driven /mvc:annotation-driven bean id= viewResolver class= org.springframework.web.servlet.view.InternalResourceViewResolver property name= prefix value= /WEB-INF/views/ /property property name= suffix value= .jsp /property /bean viewResolver - here we specify the views path and the file type (here its jsp) Create IndexController.java @Controller public class IndexController { @Autowired private MyBlogService myBlogService ; @GetMapping ( / ) public String index ( Model model ) { return redirect:/home ; } @RequestMapping ( /home ) public String Home ( Model model ) { List Post allPosts = myBlogService . listOfAllPosts (); model . addAttribute ( ListOfAllPosts , allPosts ); return home ; } } Create MyBlogDAO -- This is created using Spring Data JPA (can be coded using JPA as well. MyBlogService will get updated accordingly) import org.springframework.data.repository.PagingAndSortingRepository ; import org.springframework.stereotype.Repository ; import com.nj.blog.entities.Post ; @Repository public interface MyBlogDAO extends PagingAndSortingRepository Post , Integer { } Create MyBlogService @Component public class MyBlogService { private MyBlogDAO myBlogDAO ; @Autowired public MyBlogService ( MyBlogDAO myBlogDAO ) { this . myBlogDAO = myBlogDAO ; } public List Post listOfAllPosts () { Iterable Post iterable = myBlogDAO . findAll (); List Post allPosts = new ArrayList (); iterable . iterator (). forEachRemaining ( allPosts : : add ); return allPosts ; } public Post getPostByPostId ( int postId ) { return myBlogDAO . findOne ( postId ); } } Create home.jsp % @ taglib uri = http://java.sun.com/jsp/jstl/core prefix = c % !DOCTYPE html head meta http-equiv= Content-Type content= text/html; charset=UTF-8 title Welcome to MyBlog /title /head body table c:if test= ${ListOfAllPosts.isEmpty()} tr td colspan= 4 No Post found /td /tr /c:if c:if test= ${!ListOfAllPosts.isEmpty()} c:forEach var= allPosts items= ${ListOfAllPosts} tr td h3 b c:out value= ${allPosts.title} / /b /h3 /td /tr tr td c:out value= ${allPosts.content} / /td /tr tr td /td /tr /c:forEach /c:if /table /body /html Spring MVC configuration using Javaconfig Maven Dependencies remain same. Create MyWebAppInitializer.java class public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @ Override protected Class ? [] getRootConfigClasses () { return new Class [] { AppConfig . class }; } @ Override protected Class ? [] getServletConfigClasses () { return new Class [] { WebMvcConfig . class }; } @ Override protected String [] getServletMappings () { return new String [] { / }; } } Create WebMvcConfig.java class @Configuration @EnableWebMvc @ComponentScan ( basePackages = { com.nj.springmvcdemo.web } ) public class WebMvcConfig { @Bean public ViewResolver viewResolver () { ViewResolver resolver = new InternalResourceViewResolver ( /WEB-INF/views/ , .jsp ); return resolver ; } } Create AppConfig.java this class for including configuration related to database and so on. @Configuration // @ComponentScan ( basePackages = { com.nj.springmvcdemo.services , com.nj.springmvcdemo.dao } ) @ComponentScan ( basePackages = { com.nj.springmvcdemo } , excludeFilters = @Filter ( type = FilterType . REGEX , pattern = com.nj.springmvcdemo.web.* )) public class AppConfig { } rest all DAO, controller and so on remains same","title":"SpringMVC"},{"location":"java/spring-mvc/#spring-mvc-configuration-quick-reference","text":"","title":"Spring MVC configuration Quick Reference"},{"location":"java/spring-mvc/#introduction","text":"Spring MVC is one of the most important modules of the Spring framework","title":"Introduction"},{"location":"java/spring-mvc/#important-notes","text":"In Spring Web applications, there are two types of containers - Application context and Web Application Context. Application context is initiaized by ContextLoaderListener defined in web.xml This is a root container and generally contains components such as Services and DAO There will be one application context per application. Web Application context: This is a child context of Application context. Web Application context is initialized by Dispatcher servlet handlers/controllers/view-resolvers are managed by this context *View Resolver ViewResolver implementations are used to resolve the view pages by name we are providing the view pages directory and suffix location If a controller handler method returns \u201chome\u201d, view resolver will use view page located at /WEB-INF/views/home.jsp.","title":"Important Notes:"},{"location":"java/spring-mvc/#spring-mvc-configuration-using-xml","text":"","title":"Spring MVC configuration using XML"},{"location":"java/spring-mvc/#getting-started","text":"Maven Dependencies dependencies dependency groupId javax.servlet /groupId artifactId javax.servlet-api /artifactId scope provided /scope /dependency dependency groupId org.springframework /groupId artifactId spring-webmvc /artifactId /dependency dependency groupId org.slf4j /groupId artifactId jcl-over-slf4j /artifactId /dependency dependency groupId ch.qos.logback /groupId artifactId logback-classic /artifactId /dependency dependency groupId org.hibernate /groupId artifactId hibernate-validator /artifactId /dependency /dependencies Update web.xml file to include DispatcherServlet (one servlet) to receive all kinds of information. Here we have configured it as only one context that is WebApplication Context (but not as - Application context and WebApplication context - we have covered that scenario in javaconfig example ) servlet servlet-name dispatcher /servlet-name servlet-class org.springframework.web.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern / /url-pattern /servlet-mapping dispatcher-servlet.xml -- based on the servlet name (here \"dispatcher\", it will look for -servlet.xml file. If needed we can specify different name as well. However, here, we are creating dispatcher-servlet.xml only. / - This means for all the URL patterns, request will be handled by dispatcher. context:annotation-config /context:annotation-config context:component-scan base-package= com.nj.blog /context:component-scan mvc:annotation-driven /mvc:annotation-driven bean id= viewResolver class= org.springframework.web.servlet.view.InternalResourceViewResolver property name= prefix value= /WEB-INF/views/ /property property name= suffix value= .jsp /property /bean viewResolver - here we specify the views path and the file type (here its jsp) Create IndexController.java @Controller public class IndexController { @Autowired private MyBlogService myBlogService ; @GetMapping ( / ) public String index ( Model model ) { return redirect:/home ; } @RequestMapping ( /home ) public String Home ( Model model ) { List Post allPosts = myBlogService . listOfAllPosts (); model . addAttribute ( ListOfAllPosts , allPosts ); return home ; } } Create MyBlogDAO -- This is created using Spring Data JPA (can be coded using JPA as well. MyBlogService will get updated accordingly) import org.springframework.data.repository.PagingAndSortingRepository ; import org.springframework.stereotype.Repository ; import com.nj.blog.entities.Post ; @Repository public interface MyBlogDAO extends PagingAndSortingRepository Post , Integer { } Create MyBlogService @Component public class MyBlogService { private MyBlogDAO myBlogDAO ; @Autowired public MyBlogService ( MyBlogDAO myBlogDAO ) { this . myBlogDAO = myBlogDAO ; } public List Post listOfAllPosts () { Iterable Post iterable = myBlogDAO . findAll (); List Post allPosts = new ArrayList (); iterable . iterator (). forEachRemaining ( allPosts : : add ); return allPosts ; } public Post getPostByPostId ( int postId ) { return myBlogDAO . findOne ( postId ); } } Create home.jsp % @ taglib uri = http://java.sun.com/jsp/jstl/core prefix = c % !DOCTYPE html head meta http-equiv= Content-Type content= text/html; charset=UTF-8 title Welcome to MyBlog /title /head body table c:if test= ${ListOfAllPosts.isEmpty()} tr td colspan= 4 No Post found /td /tr /c:if c:if test= ${!ListOfAllPosts.isEmpty()} c:forEach var= allPosts items= ${ListOfAllPosts} tr td h3 b c:out value= ${allPosts.title} / /b /h3 /td /tr tr td c:out value= ${allPosts.content} / /td /tr tr td /td /tr /c:forEach /c:if /table /body /html","title":"Getting Started"},{"location":"java/spring-mvc/#spring-mvc-configuration-using-javaconfig","text":"Maven Dependencies remain same. Create MyWebAppInitializer.java class public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @ Override protected Class ? [] getRootConfigClasses () { return new Class [] { AppConfig . class }; } @ Override protected Class ? [] getServletConfigClasses () { return new Class [] { WebMvcConfig . class }; } @ Override protected String [] getServletMappings () { return new String [] { / }; } } Create WebMvcConfig.java class @Configuration @EnableWebMvc @ComponentScan ( basePackages = { com.nj.springmvcdemo.web } ) public class WebMvcConfig { @Bean public ViewResolver viewResolver () { ViewResolver resolver = new InternalResourceViewResolver ( /WEB-INF/views/ , .jsp ); return resolver ; } } Create AppConfig.java this class for including configuration related to database and so on. @Configuration // @ComponentScan ( basePackages = { com.nj.springmvcdemo.services , com.nj.springmvcdemo.dao } ) @ComponentScan ( basePackages = { com.nj.springmvcdemo } , excludeFilters = @Filter ( type = FilterType . REGEX , pattern = com.nj.springmvcdemo.web.* )) public class AppConfig { } rest all DAO, controller and so on remains same","title":"Spring MVC configuration using Javaconfig"},{"location":"java/spring/","text":"Spring configuration - XML based Quick Reference Introduction Spring is framework for dependency Injection / Inversion of Control (Dep/IOC) IoC: Rather than classes taking the control of initializing its dependencies, control will be passed to the container. IOC contaner will be responsible for initializing resources/beans and injecting them as dependencies. Dependency Injection helps in removing the hard coded dependencies and also it moves dependency resolution from compile time to run time. We can use XML/annotaion based configuration to implement dependency injection. For example, consider 3 tier architecture where we have Servlets --- services --- DAO Getting Started Maven Dependencies -- Same for all the three approaches (XML, annotation based, java config) dependencyManagement dependencies dependency groupId io.spring.platform /groupId artifactId platform-bom /artifactId version Brussels-SR4 /version type pom /type scope import /scope /dependency /dependencies /dependencyManagement dependency groupId org.springframework /groupId artifactId spring-context /artifactId /dependency Create UserController -- By UserController, we mean a servlet here. When servlet is used in web part and rest all (Service and DAO layers are configured using Spring, we still have to use \"application context\". But, if web layer is using Spring MVC, then application context is created automatically, need not configure is explicitly. public class UserController { private UserService userService ; public void setUserService ( UserService userService ) { this . userService = userService ; } public List String getNames () { return userService . getNames (); } } Create UserService public class UserService { private UserDAO userDAO ; public UserService ( UserDAO userDAO ) { super (); this . userDAO = userDAO ; } public List String getNames () { return userDAO . getNames (); } } Create UserDAO public class UserDAO { List String names ; Set String languages ; int count ; ... ... // setters and getters public void init () { System . out . println ( invoked init() method ); } public void destroy () { System . out . println ( invoked destroy() method ); } } Spring XML based configuration in src/main/resources/applicationContext.xml bean id= userDAO class= demo.UserDAO init-method= init destroy-method= destroy /bean bean id= userService class= demo.UserService constructor-arg ref= userDAO /constructor-arg /bean bean id= userController class= demo.UserController property name= userService ref= userService /property /bean Application Context for XML based Inside a Spring application are beans, and these beans interact with each other to provide the application services. The interacting beans are also called collaborators, and you can define them using application contexts. applicationContext.xml is the root context configuration for every web application. Spring loads applicationContext.xml file and creates the ApplicationContext for the whole application. There will be only one application context per web application. If you are not explicitly declaring the context configuration file name in web.xml using the contextConfigLocation param, Spring will search for the applicationContext.xml under WEB-INF folder and throw FileNotFoundException if it could not find this file. public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext( applicationContext.xml ); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); } Spring configuration - annotation based Quick Reference Create UserController @Component public class UserController { private UserService userService ; @Autowired public void setUserService ( UserService userService ) { this . userService = userService ; } public List String getNames () { return userService . getNames (); } } Create UserService @Component public class UserService { private UserDAO userDAO ; @Autowired public UserService ( UserDAO userDAO ) { super (); this . userDAO = userDAO ; } public List String getNames () { return userDAO . getNames (); } } Create UserDAO @Component public class UserDAO { List String names ; Set String languages ; int count ; ... ... // setters and getters @PostConstruct public void init () { System . out . println ( invoked init() method ); } @PreDestroy public void destroy () { System . out . println ( invoked destroy() method ); } } Spring annotation based configuration in src/main/resources/applicationContext-annotations.xml context:annotation-config /context:annotation-config context:component-scan base-package= demo /context:component-scan Application Context for annotation based public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext( applicationContext-annotations.xml ); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); } Spring configuration - java config Quick Reference Create UserController, UserService and UserDAO is same as that of annotation based. Spring java config based configuration by creating AppConfig.java class @Configuration @ComponentScan ( basePackages = { demo } ) public class AppConfig { } Application Context for java config public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); } Spring - JDBC configuration using XML In Spring JDBC configuration is always preferred using XML Configuring JDBC connection in XML files bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/test?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean Create TodoDAO -- TodoController, TodoService remains same, as these layers doesn't get impacted DB configuration. @Component public class TodoDAO { @Autowired private JdbcTemplate jdbcTemplate ; public Todo getTodo ( int todoId ) { String sql = select * from todolist where id=? ; Todo todo = jdbcTemplate . queryForObject ( sql , new Object []{ todoId } , new TodoRowMapper ()); return todo ; } ... ... // other methods } Spring - JDBC configuration along with Transaction Management using XML bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/addressbook?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean tx:annotation-driven/ bean id= transactionManager class= org.springframework.jdbc.datasource.DataSourceTransactionManager property name= dataSource ref= dataSource /property /bean Note: -- tells that Transaction manager is annotation driven. @Transaction annotation will be used. Create AddressBookDAO which includes @Transaction annotation -- AddressBookService and AddressBookController remains same. However @Transaction is more preferred in Service Layer (Here AddressBookService) , rather than DAO Layer (here AddressBookDAO) Without using Spring, if we perform plane JDBC operation then we have to explicitly mention conn.autoCommit(false) and perform the operations and finally conn.commit() or conn.rollback() to be called based on the need. But, with Spring, if we use @Transaction, it will automatically take care of setting conn.autoCommit(false), conn.commit() or conn.rollback() based on the operation. @Repository public class AddressBookDAO { private JdbcTemplate jdbcTemplate ; @Autowired public AddressBookDAO ( JdbcTemplate jdbcTemplate ) { super (); this . jdbcTemplate = jdbcTemplate ; } @Transactional public Contact createContact ( Contact contact ) { String sql = insert into contacts(name,phonenumber,email,address) values(?,?,?,?) ; final PreparedStatementCreator psc = new PreparedStatementCreator () { @Override public PreparedStatement createPreparedStatement ( final Connection connection ) throws SQLException { final PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ); ps . setString ( 1 , contact . getName ()); ps . setString ( 2 , contact . getPhoneNumber ()); ps . setString ( 3 , contact . getEmail ()); ps . setString ( 4 , contact . getAddress ()); return ps ; } } ; // The newly generated key will be saved in this object final KeyHolder holder = new GeneratedKeyHolder (); jdbcTemplate . update ( psc , holder ); final int contactId = holder . getKey (). intValue (); contact . setId ( contactId ); return contact ; } } Spring - JPA configuration It could be done using XML or java config Spring - JPA configuration using XML Maven Dependencies dependency groupId org.springframework /groupId artifactId spring-orm /artifactId /dependency dependency groupId org.hibernate /groupId artifactId hibernate-entitymanager /artifactId /dependency JPA beans Configuration *In Spring, we configure EntityManagerFactory as bean in XML. So we will not require to create any singleton class for EntityManagerFactory. We can directly declare and call \"EntityManager\" by using @PersistenceContext annotation (sample is give below AddressBookDAO). bean id= emf class= org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean property name= dataSource ref= dataSource / property name= packagesToScan value= com.nj.addressbook.entities / property name= jpaVendorAdapter bean class= org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter / /property property name= jpaProperties props prop key= hibernate.hbm2ddl.auto create-drop /prop prop key= hibernate.dialect org.hibernate.dialect.MySQL5Dialect /prop /props /property /bean bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/addressbook?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean tx:annotation-driven/ bean id= transactionManager class= org.springframework.orm.jpa.JpaTransactionManager property name= entityManagerFactory ref= emf / /bean Create AddressBookDAO @Repository public class AddressBookDAO { @PersistenceContext private EntityManager em ; public List Contact getAllContacts () { return em . createQuery ( select c from Contact c , Contact . class ). getResultList (); } @Transactional ( readOnly = true , propagation = Propagation . REQUIRED ) public Contact getContactById ( int id ) { return em . find ( Contact . class , id ); } @Transactional public Contact createContact ( Contact contact ) { em . persist ( contact ); return contact ; } } Spring - JPA configuration using Java config Maven Dependencies will remain same as mentioned in JPA XML configuration. JPA Java Configuration. Create AppConfig.java class (class name could be anything, we have named it as \"AppConfig\" here) @Configuration @ComponentScan ( basePackages = { com.nj.addressbook } ) @EnableTransactionManagement @EnableJpaRepositories ( basePackages = { com.nj.addressbook.dao } ) public class AppConfig { @Bean public DataSource dataSource () { DriverManagerDataSource dataSource = new DriverManagerDataSource (); dataSource . setDriverClassName ( com.mysql.jdbc.Driver ); dataSource . setUrl ( jdbc:mysql://localhost:3306/addressbook?useSSL=true ); dataSource . setUsername ( root ); dataSource . setPassword ( admin ); return dataSource ; } @Bean public PlatformTransactionManager transactionManager ( DataSource dataSource ) { EntityManagerFactory factory = entityManagerFactory ( dataSource ). getObject (); return new JpaTransactionManager ( factory ); } @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory ( DataSource dataSource ) { LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean (); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter (); vendorAdapter . setGenerateDdl ( Boolean . TRUE ); vendorAdapter . setShowSql ( Boolean . TRUE ); factory . setDataSource ( dataSource ); factory . setJpaVendorAdapter ( vendorAdapter ); factory . setPackagesToScan ( com.nj.addressbook ); Properties jpaProperties = new Properties (); jpaProperties . put ( hibernate.hbm2ddl.auto , update ); factory . setJpaProperties ( jpaProperties ); factory . afterPropertiesSet (); factory . setLoadTimeWeaver ( new InstrumentationLoadTimeWeaver ()); return factory ; } } XML Tag \" \" is represented as \"@EnableTransactionManagement\" in javaconfig No change in AddressBookDAO, AddressBookServices and AddressBookController","title":"Spring"},{"location":"java/spring/#spring-configuration-xml-based-quick-reference","text":"","title":"Spring configuration - XML based Quick Reference"},{"location":"java/spring/#introduction","text":"Spring is framework for dependency Injection / Inversion of Control (Dep/IOC) IoC: Rather than classes taking the control of initializing its dependencies, control will be passed to the container. IOC contaner will be responsible for initializing resources/beans and injecting them as dependencies. Dependency Injection helps in removing the hard coded dependencies and also it moves dependency resolution from compile time to run time. We can use XML/annotaion based configuration to implement dependency injection. For example, consider 3 tier architecture where we have Servlets --- services --- DAO","title":"Introduction"},{"location":"java/spring/#getting-started","text":"Maven Dependencies -- Same for all the three approaches (XML, annotation based, java config) dependencyManagement dependencies dependency groupId io.spring.platform /groupId artifactId platform-bom /artifactId version Brussels-SR4 /version type pom /type scope import /scope /dependency /dependencies /dependencyManagement dependency groupId org.springframework /groupId artifactId spring-context /artifactId /dependency Create UserController -- By UserController, we mean a servlet here. When servlet is used in web part and rest all (Service and DAO layers are configured using Spring, we still have to use \"application context\". But, if web layer is using Spring MVC, then application context is created automatically, need not configure is explicitly. public class UserController { private UserService userService ; public void setUserService ( UserService userService ) { this . userService = userService ; } public List String getNames () { return userService . getNames (); } } Create UserService public class UserService { private UserDAO userDAO ; public UserService ( UserDAO userDAO ) { super (); this . userDAO = userDAO ; } public List String getNames () { return userDAO . getNames (); } } Create UserDAO public class UserDAO { List String names ; Set String languages ; int count ; ... ... // setters and getters public void init () { System . out . println ( invoked init() method ); } public void destroy () { System . out . println ( invoked destroy() method ); } } Spring XML based configuration in src/main/resources/applicationContext.xml bean id= userDAO class= demo.UserDAO init-method= init destroy-method= destroy /bean bean id= userService class= demo.UserService constructor-arg ref= userDAO /constructor-arg /bean bean id= userController class= demo.UserController property name= userService ref= userService /property /bean Application Context for XML based Inside a Spring application are beans, and these beans interact with each other to provide the application services. The interacting beans are also called collaborators, and you can define them using application contexts. applicationContext.xml is the root context configuration for every web application. Spring loads applicationContext.xml file and creates the ApplicationContext for the whole application. There will be only one application context per web application. If you are not explicitly declaring the context configuration file name in web.xml using the contextConfigLocation param, Spring will search for the applicationContext.xml under WEB-INF folder and throw FileNotFoundException if it could not find this file. public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext( applicationContext.xml ); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); }","title":"Getting Started"},{"location":"java/spring/#spring-configuration-annotation-based-quick-reference","text":"Create UserController @Component public class UserController { private UserService userService ; @Autowired public void setUserService ( UserService userService ) { this . userService = userService ; } public List String getNames () { return userService . getNames (); } } Create UserService @Component public class UserService { private UserDAO userDAO ; @Autowired public UserService ( UserDAO userDAO ) { super (); this . userDAO = userDAO ; } public List String getNames () { return userDAO . getNames (); } } Create UserDAO @Component public class UserDAO { List String names ; Set String languages ; int count ; ... ... // setters and getters @PostConstruct public void init () { System . out . println ( invoked init() method ); } @PreDestroy public void destroy () { System . out . println ( invoked destroy() method ); } } Spring annotation based configuration in src/main/resources/applicationContext-annotations.xml context:annotation-config /context:annotation-config context:component-scan base-package= demo /context:component-scan Application Context for annotation based public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext( applicationContext-annotations.xml ); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); }","title":"Spring configuration - annotation based Quick Reference"},{"location":"java/spring/#spring-configuration-java-config-quick-reference","text":"Create UserController, UserService and UserDAO is same as that of annotation based. Spring java config based configuration by creating AppConfig.java class @Configuration @ComponentScan ( basePackages = { demo } ) public class AppConfig { } Application Context for java config public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); UserController userController = ctx.getBean( userController , UserController.class); List String names = userController.getNames(); System.err.println(names); }","title":"Spring configuration - java config Quick Reference"},{"location":"java/spring/#spring-jdbc-configuration-using-xml","text":"In Spring JDBC configuration is always preferred using XML Configuring JDBC connection in XML files bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/test?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean Create TodoDAO -- TodoController, TodoService remains same, as these layers doesn't get impacted DB configuration. @Component public class TodoDAO { @Autowired private JdbcTemplate jdbcTemplate ; public Todo getTodo ( int todoId ) { String sql = select * from todolist where id=? ; Todo todo = jdbcTemplate . queryForObject ( sql , new Object []{ todoId } , new TodoRowMapper ()); return todo ; } ... ... // other methods }","title":"Spring - JDBC configuration using XML"},{"location":"java/spring/#spring-jdbc-configuration-along-with-transaction-management-using-xml","text":"bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/addressbook?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean tx:annotation-driven/ bean id= transactionManager class= org.springframework.jdbc.datasource.DataSourceTransactionManager property name= dataSource ref= dataSource /property /bean Note: -- tells that Transaction manager is annotation driven. @Transaction annotation will be used. Create AddressBookDAO which includes @Transaction annotation -- AddressBookService and AddressBookController remains same. However @Transaction is more preferred in Service Layer (Here AddressBookService) , rather than DAO Layer (here AddressBookDAO) Without using Spring, if we perform plane JDBC operation then we have to explicitly mention conn.autoCommit(false) and perform the operations and finally conn.commit() or conn.rollback() to be called based on the need. But, with Spring, if we use @Transaction, it will automatically take care of setting conn.autoCommit(false), conn.commit() or conn.rollback() based on the operation. @Repository public class AddressBookDAO { private JdbcTemplate jdbcTemplate ; @Autowired public AddressBookDAO ( JdbcTemplate jdbcTemplate ) { super (); this . jdbcTemplate = jdbcTemplate ; } @Transactional public Contact createContact ( Contact contact ) { String sql = insert into contacts(name,phonenumber,email,address) values(?,?,?,?) ; final PreparedStatementCreator psc = new PreparedStatementCreator () { @Override public PreparedStatement createPreparedStatement ( final Connection connection ) throws SQLException { final PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ); ps . setString ( 1 , contact . getName ()); ps . setString ( 2 , contact . getPhoneNumber ()); ps . setString ( 3 , contact . getEmail ()); ps . setString ( 4 , contact . getAddress ()); return ps ; } } ; // The newly generated key will be saved in this object final KeyHolder holder = new GeneratedKeyHolder (); jdbcTemplate . update ( psc , holder ); final int contactId = holder . getKey (). intValue (); contact . setId ( contactId ); return contact ; } }","title":"Spring - JDBC configuration along with Transaction Management using XML"},{"location":"java/spring/#spring-jpa-configuration","text":"It could be done using XML or java config","title":"Spring - JPA configuration"},{"location":"java/spring/#spring-jpa-configuration-using-xml","text":"Maven Dependencies dependency groupId org.springframework /groupId artifactId spring-orm /artifactId /dependency dependency groupId org.hibernate /groupId artifactId hibernate-entitymanager /artifactId /dependency JPA beans Configuration *In Spring, we configure EntityManagerFactory as bean in XML. So we will not require to create any singleton class for EntityManagerFactory. We can directly declare and call \"EntityManager\" by using @PersistenceContext annotation (sample is give below AddressBookDAO). bean id= emf class= org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean property name= dataSource ref= dataSource / property name= packagesToScan value= com.nj.addressbook.entities / property name= jpaVendorAdapter bean class= org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter / /property property name= jpaProperties props prop key= hibernate.hbm2ddl.auto create-drop /prop prop key= hibernate.dialect org.hibernate.dialect.MySQL5Dialect /prop /props /property /bean bean id= dataSource class= org.springframework.jdbc.datasource.DriverManagerDataSource property name= driverClassName value= com.mysql.jdbc.Driver /property property name= url value= jdbc:mysql://localhost:3306/addressbook?useSSL=true /property property name= username value= root /property property name= password value= admin /property /bean bean id= jdbcTemplate class= org.springframework.jdbc.core.JdbcTemplate property name= dataSource ref= dataSource /property /bean tx:annotation-driven/ bean id= transactionManager class= org.springframework.orm.jpa.JpaTransactionManager property name= entityManagerFactory ref= emf / /bean Create AddressBookDAO @Repository public class AddressBookDAO { @PersistenceContext private EntityManager em ; public List Contact getAllContacts () { return em . createQuery ( select c from Contact c , Contact . class ). getResultList (); } @Transactional ( readOnly = true , propagation = Propagation . REQUIRED ) public Contact getContactById ( int id ) { return em . find ( Contact . class , id ); } @Transactional public Contact createContact ( Contact contact ) { em . persist ( contact ); return contact ; } }","title":"Spring - JPA configuration using XML"},{"location":"java/spring/#spring-jpa-configuration-using-java-config","text":"Maven Dependencies will remain same as mentioned in JPA XML configuration. JPA Java Configuration. Create AppConfig.java class (class name could be anything, we have named it as \"AppConfig\" here) @Configuration @ComponentScan ( basePackages = { com.nj.addressbook } ) @EnableTransactionManagement @EnableJpaRepositories ( basePackages = { com.nj.addressbook.dao } ) public class AppConfig { @Bean public DataSource dataSource () { DriverManagerDataSource dataSource = new DriverManagerDataSource (); dataSource . setDriverClassName ( com.mysql.jdbc.Driver ); dataSource . setUrl ( jdbc:mysql://localhost:3306/addressbook?useSSL=true ); dataSource . setUsername ( root ); dataSource . setPassword ( admin ); return dataSource ; } @Bean public PlatformTransactionManager transactionManager ( DataSource dataSource ) { EntityManagerFactory factory = entityManagerFactory ( dataSource ). getObject (); return new JpaTransactionManager ( factory ); } @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory ( DataSource dataSource ) { LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean (); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter (); vendorAdapter . setGenerateDdl ( Boolean . TRUE ); vendorAdapter . setShowSql ( Boolean . TRUE ); factory . setDataSource ( dataSource ); factory . setJpaVendorAdapter ( vendorAdapter ); factory . setPackagesToScan ( com.nj.addressbook ); Properties jpaProperties = new Properties (); jpaProperties . put ( hibernate.hbm2ddl.auto , update ); factory . setJpaProperties ( jpaProperties ); factory . afterPropertiesSet (); factory . setLoadTimeWeaver ( new InstrumentationLoadTimeWeaver ()); return factory ; } } XML Tag \" \" is represented as \"@EnableTransactionManagement\" in javaconfig No change in AddressBookDAO, AddressBookServices and AddressBookController","title":"Spring - JPA configuration using Java config"},{"location":"web-development/reactjs/","text":"Create React application Using npx npx create-react-app appname Install CRA globally npm install -g create-react-app create-react-app appname","title":"ReactJS"},{"location":"web-development/reactjs/#create-react-application","text":"","title":"Create React application"},{"location":"web-development/reactjs/#using-npx","text":"npx create-react-app appname","title":"Using npx"},{"location":"web-development/reactjs/#install-cra-globally","text":"npm install -g create-react-app create-react-app appname","title":"Install CRA globally"}]}